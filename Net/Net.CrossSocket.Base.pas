{******************************************************************************}
{                                                                              }
{       Delphi cross platform socket library                                   }
{                                                                              }
{       Copyright (c) 2017 WiNDDRiVER(soulawing@gmail.com)                     }
{                                                                              }
{       Homepage: https://github.com/winddriver/Delphi-Cross-Socket            }
{                                                                              }
{******************************************************************************}
unit Net.CrossSocket.Base;

// Whether to divide large blocks of data into small blocks (only valid under IOCP)
// Note: When the switch is turned on, the same connection should not start another transmission when one transmission has not ended yet.
// Otherwise, the two pieces of data will be divided into small blocks and then interleaved.
{.$DEFINE __LITTLE_PIECE__}

interface

uses
  System.SysUtils,
  System.Classes,
  System.Math,
  System.Generics.Collections,
  Net.SocketAPI;

const
  // Unique number category
  // The unique number is 64 bits, and the high 2 bits are used to indicate the category.
  UID_RAW        = $0;
  UID_LISTEN     = $1;
  UID_CONNECTION = $2;

  // Maximum unique number (62 1)
  UID_MASK       = UInt64($3FFFFFFFFFFFFFFF);

  IPv4_ALL   = '0.0.0.0';
  IPv6_ALL   = '::';
  IPv4v6_ALL = '';
  IPv4_LOCAL = '127.0.0.1';
  IPv6_LOCAL = '::1';

type
  ECrossSocket = class(Exception);

  ICrossSocket = interface;

  /// <summary>
  ///   Connection Type
  /// </summary>
  TConnectType = (
    /// <summary>
    ///   Unknown
    /// </summary>
    ctUnknown,
    /// <summary>
    ///   The connection generated by the listener Accept
    /// </summary>
    ctAccept,
    /// <summary>
    ///   The connection generated by the Connect call
    /// </summary>
    ctConnect);

  /// <summary>
  ///   Connection Status
  /// </summary>
  TConnectStatus = (
    /// <summary>
    ///   Unknown
    /// </summary>
    csUnknown,
    /// <summary>
    ///   Connecting
    /// </summary>
    csConnecting,
    /// <summary>
    ///   Shaking hands (SSL)
    /// </summary>
    csHandshaking,
    /// <summary>
    ///   Connected
    /// </summary>
    csConnected,
    /// <summary>
    ///   Has been disconnected
    /// </summary>
    csDisconnected,
    /// <summary>
    ///   Closed
    /// </summary>
    csClosed);

  /// <summary>
  ///   Basic data interface
  /// </summary>
  ICrossData = interface
  ['{988404A3-D297-4C6D-9A76-16E50553596E}']
    function GetOwner: ICrossSocket;
    function GetUID: UInt64;
    function GetSocket: THandle;
    function GetLocalAddr: string;
    function GetLocalPort: Word;
    function GetIsClosed: Boolean;
    function GetUserData: Pointer;
    function GetUserObject: TObject;
    function GetUserInterface: IInterface;

    procedure SetUserData(const AValue: Pointer);
    procedure SetUserObject(const AValue: TObject);
    procedure SetUserInterface(const AValue: IInterface);

    /// <summary>
    ///   Update socket address information
    /// </summary>
    /// <remarks>
    ///   LocalAddr, LocalPort, PeerAddr, PeerPort all depend on this method
    /// </remarks>
    procedure UpdateAddr;

    /// <summary>
    ///   Close the socket
    /// </summary>
    procedure Close;

    /// <summary>
    ///   Host object
    /// </summary>
    property Owner: ICrossSocket read GetOwner;

    /// <summary>
    ///   Unique number
    /// </summary>
    property UID: UInt64 read GetUID;

    /// <summary>
    ///   Socket handle
    /// </summary>
    property Socket: THandle read GetSocket;

    /// <summary>
    ///   Local IP address
    /// </summary>
    property LocalAddr: string read GetLocalAddr;

    /// <summary>
    ///   Local port
    /// </summary>
    property LocalPort: Word read GetLocalPort;

    /// <summary>
    ///   Is it turned off?
    /// </summary>
    property IsClosed: Boolean read GetIsClosed;

    /// <summary>
    ///   User data (can be used to store user-defined data structures)
    /// </summary>
    property UserData: Pointer read GetUserData write SetUserData;

    /// <summary>
    ///   User data (can be used to store user-defined data structures)
    /// </summary>
    property UserObject: TObject read GetUserObject write SetUserObject;

    /// <summary>
    ///   User data (can be used to store user-defined data structures)
    /// </summary>
    property UserInterface: IInterface read GetUserInterface write SetUserInterface;
  end;
  TCrossDatas = TDictionary<UInt64, ICrossData>;

  /// <summary>
  ///   Listening interface
  /// </summary>
  ICrossListen = interface(ICrossData)
  ['{4008919E-8F16-4BBD-A68D-2FD1DE630702}']
    function GetFamily: Integer;
    function GetSockType: Integer;
    function GetProtocol: Integer;

    /// <summary>
    ///   PF_xxx
    /// </summary>
    property Family: Integer read GetFamily;

    /// <summary>
    ///   SOCK_xxx
    /// </summary>
    property SockType: Integer read GetSockType;

    /// <summary>
    ///   IPPROTO_xxx
    /// </summary>
    property Protocol: Integer read GetProtocol;
  end;
  TCrossListens = TDictionary<UInt64, ICrossListen>;

  /// <summary>
  ///   Connection interface
  /// </summary>
  ICrossConnection = interface(ICrossData)
  ['{13C2A39E-C918-49B9-BBD3-A99110F94D1B}']
    function GetPeerAddr: string;
    function GetPeerPort: Word;
    function GetConnectType: TConnectType;
    function GetConnectStatus: TConnectStatus;

    procedure SetConnectStatus(const Value: TConnectStatus);

    /// <summary>
    ///   Elegantly closed
    /// </summary>
    procedure Disconnect;

    /// <summary>
    ///   Send memory block data
    /// </summary>
    /// <param name="ABuffer">
    ///   Memory block pointer
    /// </param>
    /// <param name="ACount">
    ///   Data size
    /// </param>
    /// <param name="ACallback">
    ///   Callback function called when all data is sent or when an error occurs
    /// </param>
    procedure SendBuf(ABuffer: Pointer; ACount: Integer;
      const ACallback: TProc<ICrossConnection, Boolean> = nil); overload;

    /// <summary>
    ///   Send untyped data
    /// </summary>
    /// <param name="ABuffer">
    ///   No type data
    /// </param>
    /// <param name="ACount">
    ///   Data size
    /// </param>
    /// <param name="ACallback">
    ///   Callback function called when all data is sent or when an error occurs
    /// </param>
    procedure SendBuf(const ABuffer; ACount: Integer;
      const ACallback: TProc<ICrossConnection, Boolean> = nil); overload;

    /// <summary>
    ///   Send byte data
    /// </summary>
    /// <param name="ABytes">
    ///   Byte data
    /// </param>
    /// <param name="AOffset">
    ///   Offset
    /// </param>
    /// <param name="ACount">
    ///   Data size
    /// </param>
    /// <param name="ACallback">
    ///   Callback function called when all data is sent or when an error occurs
    /// </param>
    procedure SendBytes(const ABytes: TBytes; AOffset, ACount: Integer;
      const ACallback: TProc<ICrossConnection, Boolean> = nil); overload;

    /// <summary>
    ///   Send byte data
    /// </summary>
    /// <param name="ABytes">
    ///   Byte data
    /// </param>
    /// <param name="ACallback">
    ///   Callback function called when all data is sent or when an error occurs
    /// </param>
    procedure SendBytes(const ABytes: TBytes;
      const ACallback: TProc<ICrossConnection, Boolean> = nil); overload;

    /// <summary>
    ///   Send data stream (used to send larger data)
    /// </summary>
    /// <param name="AStream">
    ///   Stream data
    /// </param>
    /// <param name="ACallback">
    ///   Callback function called when all data is sent or when an error occurs
    /// </param>
    /// <remarks>
    ///   Since it is purely asynchronous, it is important to ensure the validity of AStream during the sending process, and put the release of AStream into the callback function<br />
    /// </remarks>
    procedure SendStream(const AStream: TStream;
      const ACallback: TProc<ICrossConnection, Boolean> = nil);

    /// <summary>
    ///   Connect IP address
    /// </summary>
    property PeerAddr: string read GetPeerAddr;

    /// <summary>
    ///   Connection port
    /// </summary>
    property PeerPort: Word read GetPeerPort;

    /// <summary>
    ///   Connection Type
    /// </summary>
    /// <remarks>
    ///   <list type="bullet">
    ///     <item>
    ///       ctAccept, the connection generated by the listener Accept;
    ///     </item>
    ///     <item>
    ///       ctConnect, the connection generated by the Connect call
    ///     </item>
    ///   </list>
    /// </remarks>
    property ConnectType: TConnectType read GetConnectType;

    /// <summary>
    ///   Connection Status
    /// </summary>
    property ConnectStatus: TConnectStatus read GetConnectStatus write SetConnectStatus;
  end;
  TCrossConnections = TDictionary<UInt64, ICrossConnection>;

  TCrossListenEvent = procedure(Sender: TObject; AListen: ICrossListen) of object;
  TCrossConnectEvent = procedure(Sender: TObject; AConnection: ICrossConnection) of object;
  TCrossDataEvent = procedure(Sender: TObject; AConnection: ICrossConnection; ABuf: Pointer; ALen: Integer) of object;

  /// <summary>
  ///   Cross-platform Socket interface
  /// </summary>
  ICrossSocket = interface
  ['{2371CC3F-EB38-4C5D-8FA9-C913B9CD37A0}']
    function GetIoThreads: Integer;
    function GetConnectionsCount: Integer;
    function GetListensCount: Integer;

    function GetOnConnected: TCrossConnectEvent;
    function GetOnDisconnected: TCrossConnectEvent;
    function GetOnListened: TCrossListenEvent;
    function GetOnListenEnd: TCrossListenEvent;
    function GetOnReceived: TCrossDataEvent;
    function GetOnSent: TCrossDataEvent;

    procedure SetOnConnected(const Value: TCrossConnectEvent);
    procedure SetOnDisconnected(const Value: TCrossConnectEvent);
    procedure SetOnListened(const Value: TCrossListenEvent);
    procedure SetOnListenEnd(const Value: TCrossListenEvent);
    procedure SetOnReceived(const Value: TCrossDataEvent);
    procedure SetOnSent(const Value: TCrossDataEvent);

    /// <summary>
    ///   Start IO loop
    /// </summary>
    procedure StartLoop;

    /// <summary>
    ///   Stop IO loop
    /// </summary>
    procedure StopLoop;

    /// <summary>
    ///   Handling IO events
    /// </summary>
    function ProcessIoEvent: Boolean;

    /// <summary>
    ///   listening port
    /// </summary>
    /// <param name="AHost">
    ///   Listening address:
    ///   <list type="bullet">
    ///     <item>
    ///       To listen to all IPv4 and IPv6 addresses, set to null
    ///     </item>
    ///     <item>
    ///       To listen to IPv4 separately, set it to '0.0.0.0'
    ///     </item>
    ///     <item>
    ///       To listen to IPv6 separately, set it to '::'
    ///     </item>
    ///     <item>
    ///       To listen to the IPv4 loop address, set it to '127.0.0.1'
    ///     </item>
    ///     <item>
    ///       To listen to the IPv6 loop address, set it to '::1'
    ///     </item>
    ///   </list>
    /// </param>
    /// <param name="APort">
    ///   Listening port, set to 0 to randomly listen to an available port
    /// </param>
    /// <param name="ACallback">
    ///   Callback anonymous function
    /// </param>
    procedure Listen(const AHost: string; APort: Word;
      const ACallback: TProc<ICrossListen, Boolean> = nil);

    /// <summary>
    ///   Connect to the host
    /// </summary>
    /// <param name="AHost">
    ///   Host address
    /// </param>
    /// <param name="APort">
    ///   Host port
    /// </param>
    /// <param name="ACallback">
    ///   Callback anonymous function
    /// </param>
    procedure Connect(const AHost: string; APort: Word;
      const ACallback: TProc<ICrossConnection, Boolean> = nil);

    /// <summary>
    ///   Send data
    /// </summary>
    /// <param name="AConnection">
    ///   Connection object
    /// </param>
    /// <param name="ABuf">
    ///   Data pointer
    /// </param>
    /// <param name="ALen">
    ///   Data size
    /// </param>
    /// <param name="ACallback">
    ///   Callback anonymous function
    /// </param>
    /// <remarks>
    ///   Since the send is asynchronous, the caller is required to guarantee the validity of the data before the completion of the send
    /// </remarks>
    procedure Send(AConnection: ICrossConnection; ABuf: Pointer; ALen: Integer;
      const ACallback: TProc<ICrossConnection, Boolean> = nil);

    /// <summary>
    ///   Close all connections
    /// </summary>
    /// <remarks>
    ///   The data being sent will be lost
    /// </remarks>
    procedure CloseAllConnections;

    /// <summary>
    ///   Turn off all listeners
    /// </summary>
    procedure CloseAllListens;

    /// <summary>
    ///   Turn off all listeners and connections
    /// </summary>
    procedure CloseAll;

    /// <summary>
    ///   Disconnect all connections
    /// </summary>
    /// <remarks>
    ///   The data being sent will be delivered
    /// </remarks>
    procedure DisconnectAll;

    /// <summary>
    ///   Lock and return all connections
    /// </summary>
    function LockConnections: TCrossConnections;

    /// <summary>
    ///   Unlock the connection
    /// </summary>
    procedure UnlockConnections;

    /// <summary>
    ///   Lock and return all listeners
    /// </summary>
    function LockListens: TCrossListens;

    /// <summary>
    ///   Unlock the listener
    /// </summary>
    procedure UnlockListens;

    /// <summary>
    ///   Create a connection object (internal use)
    /// </summary>
    function CreateConnection(AOwner: ICrossSocket; AClientSocket: THandle;
      AConnectType: TConnectType): ICrossConnection;

    /// <summary>
    ///   Create a listener object (internal use)
    /// </summary>
    function CreateListen(AOwner: ICrossSocket; AListenSocket: THandle;
      AFamily, ASockType, AProtocol: Integer): ICrossListen;

    {$region 'physical event'}
    /// <summary>
    ///   Trigger after successful monitoring (internal use)
    /// </summary>
    /// <param name="AListen">
    ///   Listener object
    /// </param>
    procedure TriggerListened(AListen: ICrossListen);

    /// <summary>
    ///   Trigger after listening (internal use)
    /// </summary>
    /// <param name="AListen">
    ///   Listener object
    /// </param>
    procedure TriggerListenEnd(AListen: ICrossListen);

    /// <summary>
    ///   Connecting (internal use)
    /// </summary>
    /// <param name="AConnection">
    ///   Connection object
    /// </param>
    procedure TriggerConnecting(AConnection: ICrossConnection);

    /// <summary>
    ///   Trigger after successful connection (internal use)
    /// </summary>
    /// <param name="AConnection">
    ///   Connection object
    /// </param>
    procedure TriggerConnected(AConnection: ICrossConnection);

    /// <summary>
    ///   Trigger after disconnection (internal use)
    /// </summary>
    /// <param name="AConnection">
    ///   Connection object
    /// </param>
    procedure TriggerDisconnected(AConnection: ICrossConnection);
    {$endregion}

    /// <summary>
    ///   IO threads
    /// </summary>
    property IoThreads: Integer read GetIoThreads;

    /// <summary>
    ///   Number of connections
    /// </summary>
    property ConnectionsCount: Integer read GetConnectionsCount;

    /// <summary>
    ///   Listening number
    /// </summary>
    property ListensCount: Integer read GetListensCount;

    /// <summary>
    ///   Listen for success events
    /// </summary>
    property OnListened: TCrossListenEvent read GetOnListened write SetOnListened;

    /// <summary>
    ///   Listening end event
    /// </summary>
    property OnListenEnd: TCrossListenEvent read GetOnListenEnd write SetOnListenEnd;

    /// <summary>
    ///   Connection success event
    /// </summary>
    property OnConnected: TCrossConnectEvent read GetOnConnected write SetOnConnected;

    /// <summary>
    ///   Connection disconnect event
    /// </summary>
    property OnDisconnected: TCrossConnectEvent read GetOnDisconnected write SetOnDisconnected;

    /// <summary>
    ///   Receive data event
    /// </summary>
    property OnReceived: TCrossDataEvent read GetOnReceived write SetOnReceived;

    /// <summary>
    ///   Issue a data event
    /// </summary>
    property OnSent: TCrossDataEvent read GetOnSent write SetOnSent;
  end;

  TCrossData = class abstract(TInterfacedObject, ICrossData)
  private
    class var FCrossUID: UInt64;
  private
    [weak]FOwner: ICrossSocket;
    FUID: UInt64;
    FSocket: THandle;
    FLocalAddr: string;
    FLocalPort: Word;
    FUserData: Pointer;
    FUserObject: TObject;
    FUserInterface: IInterface;
  protected
    function GetOwner: ICrossSocket;
    function GetUIDTag: Byte; virtual;
    function GetUID: UInt64;
    function GetSocket: THandle;
    function GetLocalAddr: string;
    function GetLocalPort: Word;
    function GetIsClosed: Boolean; virtual; abstract;
    function GetUserData: Pointer;
    function GetUserObject: TObject;
    function GetUserInterface: IInterface;

    procedure SetUserData(const AValue: Pointer);
    procedure SetUserObject(const AValue: TObject);
    procedure SetUserInterface(const AValue: IInterface);
  public
    constructor Create(AOwner: ICrossSocket; ASocket: THandle); virtual;
    destructor Destroy; override;

    procedure UpdateAddr; virtual;
    procedure Close; virtual; abstract;

    property Owner: ICrossSocket read GetOwner;
    property UID: UInt64 read GetUID;
    property Socket: THandle read GetSocket;
    property LocalAddr: string read GetLocalAddr;
    property LocalPort: Word read GetLocalPort;
    property IsClosed: Boolean read GetIsClosed;
    property UserData: Pointer read GetUserData write SetUserData;
    property UserObject: TObject read GetUserObject write SetUserObject;
    property UserInterface: IInterface read GetUserInterface write SetUserInterface;
  end;

  TAbstractCrossListen = class(TCrossData, ICrossListen)
  private
    FFamily: Integer;
    FSockType: Integer;
    FProtocol: Integer;
    FClosed: Integer;
  protected
    function GetUIDTag: Byte; override;
    function GetFamily: Integer;
    function GetSockType: Integer;
    function GetProtocol: Integer;
    function GetIsClosed: Boolean; override;
  public
    constructor Create(AOwner: ICrossSocket; AListenSocket: THandle;
      AFamily, ASockType, AProtocol: Integer); reintroduce; virtual;

    procedure Close; override;

    property Owner: ICrossSocket read GetOwner;
    property Socket: THandle read GetSocket;
    property LocalAddr: string read GetLocalAddr;
    property LocalPort: Word read GetLocalPort;
    property IsClosed: Boolean read GetIsClosed;
  end;

  TAbstractCrossConnection = class(TCrossData, ICrossConnection)
  public const
    SND_BUF_SIZE = 32768;
  private
    FPeerAddr: string;
    FPeerPort: Word;
    FConnectType: TConnectType;
    FConnectStatus: Integer;
  protected
    function GetUIDTag: Byte; override;
    function GetPeerAddr: string;
    function GetPeerPort: Word;
    function GetConnectType: TConnectType;
    function GetConnectStatus: TConnectStatus;
    function GetIsClosed: Boolean; override;

    function _SetConnectStatus(const AStatus: TConnectStatus): TConnectStatus; inline;
    procedure SetConnectStatus(const Value: TConnectStatus);

    procedure DirectSend(ABuffer: Pointer; ACount: Integer;
      const ACallback: TProc<ICrossConnection, Boolean> = nil); virtual;
  public
    constructor Create(AOwner: ICrossSocket; AClientSocket: THandle;
      AConnectType: TConnectType); reintroduce; virtual;

    procedure UpdateAddr; override;
    procedure Close; override;
    procedure Disconnect; virtual;

    procedure SendBuf(ABuffer: Pointer; ACount: Integer;
      const ACallback: TProc<ICrossConnection, Boolean> = nil); overload;
    procedure SendBuf(const ABuffer; ACount: Integer;
      const ACallback: TProc<ICrossConnection, Boolean> = nil); overload; inline;
    procedure SendBytes(const ABytes: TBytes; AOffset, ACount: Integer;
      const ACallback: TProc<ICrossConnection, Boolean> = nil); overload;
    procedure SendBytes(const ABytes: TBytes;
      const ACallback: TProc<ICrossConnection, Boolean> = nil); overload; inline;
    procedure SendStream(const AStream: TStream;
      const ACallback: TProc<ICrossConnection, Boolean> = nil);

    property Owner: ICrossSocket read GetOwner;
    property Socket: THandle read GetSocket;
    property LocalAddr: string read GetLocalAddr;
    property LocalPort: Word read GetLocalPort;
    property IsClosed: Boolean read GetIsClosed;

    property PeerAddr: string read GetPeerAddr;
    property PeerPort: Word read GetPeerPort;
    property ConnectType: TConnectType read GetConnectType;
    property ConnectStatus: TConnectStatus read GetConnectStatus write SetConnectStatus;
  end;

  TIoEventThread = class(TThread)
  private
    FCrossSocket: ICrossSocket;
  protected
    procedure Execute; override;
  public
    constructor Create(ACrossSocket: ICrossSocket); reintroduce;
  end;

  TAbstractCrossSocket = class abstract(TInterfacedObject, ICrossSocket)
  protected const
    RCV_BUF_SIZE = 32768;
  protected class threadvar
    FRecvBuf: array [0..RCV_BUF_SIZE-1] of Byte;
  protected
    FIoThreads: Integer;

    // Set the socket heartbeat parameters, used to handle abnormal disconnection (network cable, host abnormal power failure, etc.)
    function SetKeepAlive(ASocket: THandle): Integer;
  private
    FConnections: TCrossConnections;
    FConnectionsLock: TObject;

    FListens: TCrossListens;
    FListensLock: TObject;

    FOnListened: TCrossListenEvent;
    FOnListenEnd: TCrossListenEvent;
    FOnConnected: TCrossConnectEvent;
    FOnDisconnected: TCrossConnectEvent;
    FOnReceived: TCrossDataEvent;
    FOnSent: TCrossDataEvent;

    procedure _LockConnections; inline;
    procedure _UnlockConnections; inline;

    procedure _LockListens; inline;
    procedure _UnlockListens; inline;

    function GetConnectionsCount: Integer;
    function GetListensCount: Integer;

    function GetOnConnected: TCrossConnectEvent;
    function GetOnDisconnected: TCrossConnectEvent;
    function GetOnListened: TCrossListenEvent;
    function GetOnListenEnd: TCrossListenEvent;
    function GetOnReceived: TCrossDataEvent;
    function GetOnSent: TCrossDataEvent;

    procedure SetOnConnected(const Value: TCrossConnectEvent);
    procedure SetOnDisconnected(const Value: TCrossConnectEvent);
    procedure SetOnListened(const Value: TCrossListenEvent);
    procedure SetOnListenEnd(const Value: TCrossListenEvent);
    procedure SetOnReceived(const Value: TCrossDataEvent);
    procedure SetOnSent(const Value: TCrossDataEvent);
  protected
    FConnectionsCount: Integer;
    FListensCount: Integer;

    function ProcessIoEvent: Boolean; virtual; abstract;
    function GetIoThreads: Integer; virtual;

    // Create a connection object
    function CreateConnection(AOwner: ICrossSocket; AClientSocket: THandle;
      AConnectType: TConnectType): ICrossConnection; virtual; abstract;

    // Create a listener
    function CreateListen(AOwner: ICrossSocket; AListenSocket: THandle;
      AFamily, ASockType, AProtocol: Integer): ICrossListen; virtual; abstract;

    {$region 'physical event'}
    procedure TriggerListened(AListen: ICrossListen); virtual;
    procedure TriggerListenEnd(AListen: ICrossListen); virtual;

    procedure TriggerConnecting(AConnection: ICrossConnection); virtual;
    procedure TriggerConnected(AConnection: ICrossConnection); virtual;
    procedure TriggerDisconnected(AConnection: ICrossConnection); virtual;

    procedure TriggerReceived(AConnection: ICrossConnection; ABuf: Pointer; ALen: Integer); virtual;
    procedure TriggerSent(AConnection: ICrossConnection; ABuf: Pointer; ALen: Integer); virtual;
    {$endregion}

    {$region 'logical event'}
    // These virtual methods are used in derived classes
    // For example, the network port in SSL receives encrypted data, and it may take several times to receive a complete one.
    // Encrypted packets before decrypting the data, which means that the network port may be received several times.
    // will correspond to an actual data reception, so the following interfaces are designed. The following interfaces are actual data.
    // will be triggered when it happens
    procedure LogicConnected(AConnection: ICrossConnection); virtual;
    procedure LogicDisconnected(AConnection: ICrossConnection); virtual;
    procedure LogicReceived(AConnection: ICrossConnection; ABuf: Pointer; ALen: Integer); virtual;
    procedure LogicSent(AConnection: ICrossConnection; ABuf: Pointer; ALen: Integer); virtual;
    {$endregion}

    procedure StartLoop; virtual; abstract;
    procedure StopLoop; virtual; abstract;

    procedure Listen(const AHost: string; APort: Word;
      const ACallback: TProc<ICrossListen, Boolean> = nil); virtual; abstract;

    procedure Connect(const AHost: string; APort: Word;
      const ACallback: TProc<ICrossConnection, Boolean> = nil); virtual; abstract;

    procedure Send(AConnection: ICrossConnection; ABuf: Pointer; ALen: Integer;
      const ACallback: TProc<ICrossConnection, Boolean> = nil); virtual; abstract;

    procedure CloseAllConnections; virtual;
    procedure CloseAllListens; virtual;
    procedure CloseAll; virtual;
    procedure DisconnectAll; virtual;
  public
    constructor Create(AIoThreads: Integer); virtual;
    destructor Destroy; override;

    procedure AfterConstruction; override;
    procedure BeforeDestruction; override;

    function LockConnections: TCrossConnections;
    procedure UnlockConnections;

    function LockListens: TCrossListens;
    procedure UnlockListens;

    property IoThreads: Integer read GetIoThreads;
    property ConnectionsCount: Integer read GetConnectionsCount;
    property ListensCount: Integer read GetListensCount;

    property OnListened: TCrossListenEvent read GetOnListened write SetOnListened;
    property OnListenEnd: TCrossListenEvent read GetOnListenEnd write SetOnListenEnd;
    property OnConnected: TCrossConnectEvent read GetOnConnected write SetOnConnected;
    property OnDisconnected: TCrossConnectEvent read GetOnDisconnected write SetOnDisconnected;
    property OnReceived: TCrossDataEvent read GetOnReceived write SetOnReceived;
    property OnSent: TCrossDataEvent read GetOnSent write SetOnSent;
  end;

  function GetTagByUID(const AUID: UInt64): Byte;

  procedure _LogLastOsError(const ATag: string = '');
  procedure _Log(const S: string); overload;
  procedure _Log(const Fmt: string; const Args: array of const); overload;

implementation

uses
  Utils.Logger;

function GetTagByUID(const AUID: UInt64): Byte;
begin
  // take the highest 2 digits
  Result := (AUID shr 62) and $03;
end;

procedure _Log(const S: string); overload;
begin
  if IsConsole then
    Writeln(S)
  else
    AppendLog(S);
end;

procedure _Log(const Fmt: string; const Args: array of const); overload;
begin
  _Log(Format(Fmt, Args));
end;

procedure _LogLastOsError(const ATag: string);
{$IFDEF DEBUG}
var
  LError: Integer;
  LErrMsg: string;
{$ENDIF}
begin
  {$IFDEF DEBUG}
  LError := GetLastError;
  if (ATag <> '') then
    LErrMsg := ATag + ' : '
  else
    LErrMsg := '';
  LErrMsg := LErrMsg + Format('System Error.  Code: %0:d(%0:.4x), %1:s',
    [LError, SysErrorMessage(LError)]);
  _Log(LErrMsg);
  {$ENDIF}
end;

{ TIoEventThread }

constructor TIoEventThread.Create(ACrossSocket: ICrossSocket);
begin
  inherited Create(True);
  FCrossSocket := ACrossSocket;
  Suspended := False;
end;

procedure TIoEventThread.Execute;
{$IFDEF DEBUG}
var
  LRunCount: Int64;
{$ENDIF}
begin
  {$IFDEF DEBUG}
  LRunCount := 0;
  {$ENDIF}
  while not Terminated do
  begin
    try
      if not FCrossSocket.ProcessIoEvent then Break;
    except
      {$IFDEF DEBUG}
      on e: Exception do
        _Log('%s Io thread ID %d, exception %s, %s', [TAbstractCrossSocket(FCrossSocket).ClassName, Self.ThreadID, e.ClassName, e.Message]);
      {$ENDIF}
    end;
    {$IFDEF DEBUG}
    Inc(LRunCount)
    {$ENDIF};
  end;
  {$IFDEF DEBUG}
//  _Log('%s Io thread ID %d, %d times called, [TAbstractCrossSocket(FCrossSocket).ClassName, Self.ThreadID, LRunCount]);
  {$ENDIF}
end;

{ TAbstractCrossSocket }

procedure TAbstractCrossSocket.CloseAll;
begin
  CloseAllListens;
  CloseAllConnections;
end;

procedure TAbstractCrossSocket.CloseAllConnections;
var
  LLConnectionArr: TArray<ICrossConnection>;
  LConnection: ICrossConnection;
begin
  _LockConnections;
  try
    LLConnectionArr := FConnections.Values.ToArray;
  finally
    _UnlockConnections;
  end;

  for LConnection in LLConnectionArr do
    LConnection.Close;
end;

procedure TAbstractCrossSocket.CloseAllListens;
var
  LListenArr: TArray<ICrossListen>;
  LListen: ICrossListen;
begin
  _LockListens;
  try
    LListenArr := FListens.Values.ToArray;
  finally
    _UnlockListens;
  end;

  for LListen in LListenArr do
    LListen.Close;
end;

constructor TAbstractCrossSocket.Create(AIoThreads: Integer);
begin
  FIoThreads := AIoThreads;

  FListens := TCrossListens.Create;
  FListensLock := TObject.Create;

  FConnections := TCrossConnections.Create;
  FConnectionsLock := TObject.Create;
end;

destructor TAbstractCrossSocket.Destroy;
begin
  FreeAndNil(FListens);
  FreeAndNil(FListensLock);

  FreeAndNil(FConnections);
  FreeAndNil(FConnectionsLock);

  inherited;
end;

procedure TAbstractCrossSocket.DisconnectAll;
var
  LLConnectionArr: TArray<ICrossConnection>;
  LConnection: ICrossConnection;
begin
  _LockConnections;
  try
    LLConnectionArr := FConnections.Values.ToArray;
  finally
    _UnlockConnections;
  end;

  for LConnection in LLConnectionArr do
    LConnection.Disconnect;
end;

procedure TAbstractCrossSocket.AfterConstruction;
begin
  inherited AfterConstruction;
  StartLoop;
end;

procedure TAbstractCrossSocket.BeforeDestruction;
begin
  StopLoop;
  inherited BeforeDestruction;
end;

function TAbstractCrossSocket.GetConnectionsCount: Integer;
begin
  Result := FConnectionsCount;
end;

function TAbstractCrossSocket.GetIoThreads: Integer;
begin
  if (FIoThreads > 0) then
    Result := FIoThreads
  else
    Result := CPUCount * 2 + 1;
end;

function TAbstractCrossSocket.GetListensCount: Integer;
begin
  Result := FListensCount;
end;

function TAbstractCrossSocket.GetOnConnected: TCrossConnectEvent;
begin
  Result := FOnConnected;
end;

function TAbstractCrossSocket.GetOnDisconnected: TCrossConnectEvent;
begin
  Result := FOnDisconnected;
end;

function TAbstractCrossSocket.GetOnListened: TCrossListenEvent;
begin
  Result := FOnListened;
end;

function TAbstractCrossSocket.GetOnListenEnd: TCrossListenEvent;
begin
  Result := FOnListenEnd;
end;

function TAbstractCrossSocket.GetOnReceived: TCrossDataEvent;
begin
  Result := FOnReceived;
end;

function TAbstractCrossSocket.GetOnSent: TCrossDataEvent;
begin
  Result := FOnSent;
end;

function TAbstractCrossSocket.LockConnections: TCrossConnections;
begin
  _LockConnections;
  Result := FConnections;
end;

function TAbstractCrossSocket.LockListens: TCrossListens;
begin
  _LockListens;
  Result := FListens;
end;

procedure TAbstractCrossSocket.LogicConnected(AConnection: ICrossConnection);
begin

end;

procedure TAbstractCrossSocket.LogicDisconnected(AConnection: ICrossConnection);
begin

end;

procedure TAbstractCrossSocket.LogicReceived(AConnection: ICrossConnection;
  ABuf: Pointer; ALen: Integer);
begin

end;

procedure TAbstractCrossSocket.LogicSent(AConnection: ICrossConnection;
  ABuf: Pointer; ALen: Integer);
begin

end;

function TAbstractCrossSocket.SetKeepAlive(ASocket: THandle): Integer;
begin
  Result := TSocketAPI.SetKeepAlive(ASocket, 5, 3, 5);
end;

procedure TAbstractCrossSocket.SetOnConnected(const Value: TCrossConnectEvent);
begin
  FOnConnected := Value;
end;

procedure TAbstractCrossSocket.SetOnDisconnected(const Value: TCrossConnectEvent);
begin
  FOnDisconnected := Value;
end;

procedure TAbstractCrossSocket.SetOnListened(const Value: TCrossListenEvent);
begin
  FOnListened := Value;
end;

procedure TAbstractCrossSocket.SetOnListenEnd(const Value: TCrossListenEvent);
begin
  FOnListenEnd := Value;
end;

procedure TAbstractCrossSocket.SetOnReceived(const Value: TCrossDataEvent);
begin
  FOnReceived := Value;
end;

procedure TAbstractCrossSocket.SetOnSent(const Value: TCrossDataEvent);
begin
  FOnSent := Value;
end;

procedure TAbstractCrossSocket.TriggerConnecting(AConnection: ICrossConnection);
begin
  AConnection.ConnectStatus := csConnecting;

  _LockConnections;
  try
    FConnections.AddOrSetValue(AConnection.UID, AConnection);
    FConnectionsCount := FConnections.Count;
  finally
    _UnlockConnections;
  end;
end;

procedure TAbstractCrossSocket.TriggerConnected(AConnection: ICrossConnection);
begin
  AConnection.UpdateAddr;
  AConnection.ConnectStatus := csConnected;

  LogicConnected(AConnection);

  if Assigned(FOnConnected) then
    FOnConnected(Self, AConnection);
end;

procedure TAbstractCrossSocket.TriggerDisconnected(AConnection: ICrossConnection);
begin
  AConnection.ConnectStatus := csClosed;

  _LockConnections;
  try
    if not FConnections.ContainsKey(AConnection.UID) then Exit;
    FConnections.Remove(AConnection.UID);
    FConnectionsCount := FConnections.Count;
  finally
    _UnlockConnections;
  end;

  LogicDisconnected(AConnection);

  if Assigned(FOnDisconnected) then
    FOnDisconnected(Self, AConnection);
end;

procedure TAbstractCrossSocket.TriggerListened(AListen: ICrossListen);
begin
  AListen.UpdateAddr;

  _LockListens;
  try
    FListens.AddOrSetValue(AListen.UID, AListen);
    FListensCount := FListens.Count;
  finally
    _UnlockListens;
  end;

  if Assigned(FOnListened) then
    FOnListened(Self, AListen);
end;

procedure TAbstractCrossSocket.TriggerListenEnd(AListen: ICrossListen);
begin
  _LockListens;
  try
    if not FListens.ContainsKey(AListen.UID) then Exit;
    FListens.Remove(AListen.UID);
    FListensCount := FListens.Count;
  finally
    _UnlockListens;
  end;

  if Assigned(FOnListenEnd) then
    FOnListenEnd(Self, AListen);
end;

procedure TAbstractCrossSocket.TriggerReceived(AConnection: ICrossConnection;
  ABuf: Pointer; ALen: Integer);
begin
  LogicReceived(AConnection, ABuf, ALen);

  if Assigned(FOnReceived) then
    FOnReceived(Self, AConnection, ABuf, ALen);
end;

procedure TAbstractCrossSocket.TriggerSent(AConnection: ICrossConnection;
  ABuf: Pointer; ALen: Integer);
begin
  LogicSent(AConnection, ABuf, ALen);

  if Assigned(FOnSent) then
    FOnSent(Self, AConnection, ABuf, ALen);
end;

procedure TAbstractCrossSocket.UnlockConnections;
begin
  _UnlockConnections;
end;

procedure TAbstractCrossSocket.UnlockListens;
begin
  _UnlockListens;
end;

procedure TAbstractCrossSocket._LockConnections;
begin
  System.TMonitor.Enter(FConnectionsLock);
end;

procedure TAbstractCrossSocket._LockListens;
begin
  System.TMonitor.Enter(FListensLock);
end;

procedure TAbstractCrossSocket._UnlockConnections;
begin
  System.TMonitor.Exit(FConnectionsLock);
end;

procedure TAbstractCrossSocket._UnlockListens;
begin
  System.TMonitor.Exit(FListensLock);
end;

{ TCrossData }

constructor TCrossData.Create(AOwner: ICrossSocket; ASocket: THandle);
begin
  // Theoretically, the unique number of 62 will never run out.
  // So there is no need to consider the issue of number resetting.
  FUID :=
    // high 2 bit flag
    (UInt64(GetUIDTag and $03) shl 62) or
    // low 62 digits
    (UID_MASK and AtomicIncrement(FCrossUID));

  FOwner := AOwner;
  FSocket := ASocket;
end;

destructor TCrossData.Destroy;
begin
  if (FSocket <> INVALID_HANDLE_VALUE) then
  begin
    TSocketAPI.CloseSocket(FSocket);
    {$IFDEF DEBUG}
//    _Log('close result %d', [GetLastError]);
    {$ENDIF}
    FSocket := INVALID_HANDLE_VALUE;
  end;

  inherited;
end;

function TCrossData.GetLocalAddr: string;
begin
  Result := FLocalAddr;
end;

function TCrossData.GetLocalPort: Word;
begin
  Result := FLocalPort;
end;

function TCrossData.GetOwner: ICrossSocket;
begin
  Result := FOwner;
end;

function TCrossData.GetSocket: THandle;
begin
  Result := FSocket;
end;

function TCrossData.GetUID: UInt64;
begin
  Result := FUID;
end;

function TCrossData.GetUIDTag: Byte;
begin
  Result := UID_RAW;
end;

function TCrossData.GetUserData: Pointer;
begin
  Result := FUserData;
end;

function TCrossData.GetUserInterface: IInterface;
begin
  Result := FUserInterface;
end;

function TCrossData.GetUserObject: TObject;
begin
  Result := FUserObject;
end;

procedure TCrossData.SetUserData(const AValue: Pointer);
begin
  FUserData := AValue;
end;

procedure TCrossData.SetUserInterface(const AValue: IInterface);
begin
  FUserInterface := AValue;
end;

procedure TCrossData.SetUserObject(const AValue: TObject);
begin
  FUserObject := AValue;
end;

procedure TCrossData.UpdateAddr;
var
  LAddr: TRawSockAddrIn;
begin
  {$region 'local address information'}
  FillChar(LAddr, SizeOf(TRawSockAddrIn), 0);
  LAddr.AddrLen := SizeOf(LAddr.Addr6);
  if (TSocketAPI.GetSockName(FSocket, @LAddr.Addr, LAddr.AddrLen) = 0) then
    TSocketAPI.ExtractAddrInfo(@LAddr.Addr, LAddr.AddrLen,
      FLocalAddr, FLocalPort);
  {$endregion}
end;

{ TAbstractCrossListen }

constructor TAbstractCrossListen.Create(AOwner: ICrossSocket; AListenSocket: THandle;
  AFamily, ASockType, AProtocol: Integer);
begin
  inherited Create(AOwner, AListenSocket);

  FFamily := AFamily;
  FSockType := ASockType;
  FProtocol := AProtocol;

  FClosed := 0;
end;

procedure TAbstractCrossListen.Close;
begin
  if (AtomicExchange(FClosed, 1) = 1) then Exit;

  if (FSocket <> INVALID_HANDLE_VALUE) then
  begin
    TSocketAPI.CloseSocket(FSocket);
    FOwner.TriggerListenEnd(Self);
    FSocket := INVALID_HANDLE_VALUE;
  end;
end;

function TAbstractCrossListen.GetFamily: Integer;
begin
  Result := FFamily;
end;

function TAbstractCrossListen.GetIsClosed: Boolean;
begin
  Result := (FClosed = 1);
end;

function TAbstractCrossListen.GetProtocol: Integer;
begin
  Result := FProtocol;
end;

function TAbstractCrossListen.GetSockType: Integer;
begin
  Result := FSockType;
end;

function TAbstractCrossListen.GetUIDTag: Byte;
begin
  Result := UID_LISTEN;
end;

{ TAbstractCrossConnection }

constructor TAbstractCrossConnection.Create(AOwner: ICrossSocket;
  AClientSocket: THandle; AConnectType: TConnectType);
begin
  inherited Create(AOwner, AClientSocket);

  FConnectType := AConnectType;
end;

procedure TAbstractCrossConnection.SetConnectStatus(const Value: TConnectStatus);
begin
  _SetConnectStatus(Value);
end;

procedure TAbstractCrossConnection.Close;
begin
  if (_SetConnectStatus(csClosed) = csClosed) then Exit;

  if (FSocket <> INVALID_HANDLE_VALUE) then
  begin
    TSocketAPI.CloseSocket(FSocket);
    FOwner.TriggerDisconnected(Self);
    FSocket := INVALID_HANDLE_VALUE;
  end;
end;

procedure TAbstractCrossConnection.DirectSend(ABuffer: Pointer; ACount: Integer;
  const ACallback: TProc<ICrossConnection, Boolean>);
var
  LConnection: ICrossConnection;
  LBuffer: Pointer;
begin
  LConnection := Self as ICrossConnection;

  if (FSocket = INVALID_HANDLE_VALUE)
    or IsClosed then
  begin
    if Assigned(ACallback) then
      ACallback(LConnection, False);
    Exit;
  end;

  LBuffer := ABuffer;
  FOwner.Send(LConnection, LBuffer, ACount,
    procedure(AConnection: ICrossConnection; ASuccess: Boolean)
    begin
      if ASuccess then
        (FOwner as TAbstractCrossSocket).TriggerSent(AConnection, LBuffer, ACount);

      if Assigned(ACallback) then
        ACallback(AConnection, ASuccess);
    end);
end;

procedure TAbstractCrossConnection.Disconnect;
begin
  if (_SetConnectStatus(csDisconnected) in [csDisconnected, csClosed]) then Exit;

  TSocketAPI.Shutdown(FSocket, 2);
end;

function TAbstractCrossConnection.GetConnectStatus: TConnectStatus;
begin
  Result := TConnectStatus(AtomicCmpExchange(FConnectStatus, 0, 0));
end;

function TAbstractCrossConnection.GetConnectType: TConnectType;
begin
  Result := FConnectType;
end;

function TAbstractCrossConnection.GetIsClosed: Boolean;
begin
  Result := (GetConnectStatus = csClosed);
end;

function TAbstractCrossConnection.GetPeerAddr: string;
begin
  Result := FPeerAddr;
end;

function TAbstractCrossConnection.GetPeerPort: Word;
begin
  Result := FPeerPort;
end;

function TAbstractCrossConnection.GetUIDTag: Byte;
begin
  Result := UID_CONNECTION;
end;

procedure TAbstractCrossConnection.SendBuf(ABuffer: Pointer; ACount: Integer;
  const ACallback: TProc<ICrossConnection, Boolean>);
{$IF defined(POSIX) or not defined(__LITTLE_PIECE__)}
begin
  DirectSend(ABuffer, ACount, ACallback);
end;
{$ELSE} // MSWINDOWS
// iocp send data under Windows will lock non-page memory, in order to reduce the occupation of non-page memory
// Adopt the strategy of sending big data into small blocks, send the next one after sending a small block.
var
  LConnection: ICrossConnection;
  P: PByte;
  LSize: Integer;
  LSender: TProc<ICrossConnection, Boolean>;
begin
  LConnection := Self;
  P := ABuffer;
  LSize := ACount;

  LSender :=
    procedure(AConnection: ICrossConnection; ASuccess: Boolean)
    var
      LData: Pointer;
      LCount: Integer;
    begin
      if not ASuccess then
      begin
        LSender := nil;
        AConnection.Close;

        if Assigned(ACallback) then
          ACallback(AConnection, False);

        Exit;
      end;

      LData := P;
      LCount := Min(LSize, SND_BUF_SIZE);

      if (LSize > LCount) then
      begin
        Inc(P, LCount);
        Dec(LSize, LCount);
      end else
      begin
        LSize := 0;
        P := nil;
      end;

      if (LData = nil) or (LCount <= 0) then
      begin
        LSender := nil;

        if Assigned(ACallback) then
          ACallback(AConnection, True);

        Exit;
      end;

      TAbstractCrossConnection(AConnection).DirectSend(LData, LCount, LSender);
    end;

  LSender(LConnection, True);
end;
{$ENDIF}

procedure TAbstractCrossConnection.SendBuf(const ABuffer; ACount: Integer;
  const ACallback: TProc<ICrossConnection, Boolean>);
begin
  SendBuf(@ABuffer, ACount, ACallback);
end;

procedure TAbstractCrossConnection.SendBytes(const ABytes: TBytes; AOffset,
  ACount: Integer; const ACallback: TProc<ICrossConnection, Boolean>);
var
  LBytes: TBytes;
begin
  // increase the reference count
  // Since SendBuf's ABuffer parameter is a directly passed memory address
  // So it doesn't increase the reference count of ABytes, here to ensure the validity of the data during the transmission process.
  // need to define a local variable to reference ABytes to maintain its reference count
  LBytes := ABytes;
  SendBuf(@LBytes[AOffset], ACount,
    procedure(AConnection: ICrossConnection; ASuccess: Boolean)
    begin
      // Reduce the reference count
      LBytes := nil;

      if Assigned(ACallback) then
        ACallback(AConnection, ASuccess);
    end);
end;

procedure TAbstractCrossConnection.SendBytes(const ABytes: TBytes;
  const ACallback: TProc<ICrossConnection, Boolean>);
begin
  SendBytes(ABytes, 0, Length(ABytes), ACallback);
end;

procedure TAbstractCrossConnection.SendStream(const AStream: TStream;
  const ACallback: TProc<ICrossConnection, Boolean>);
var
  LConnection: ICrossConnection;
  LBuffer: TBytes;
  LSender: TProc<ICrossConnection, Boolean>;
begin
  if (AStream is TBytesStream) then
  begin
    SendBytes(
      TBytesStream(AStream).Bytes,
      TBytesStream(AStream).Position,
      TBytesStream(AStream).Size - TBytesStream(AStream).Position,
      ACallback);
    Exit;
  end;

  LConnection := Self;
  SetLength(LBuffer, SND_BUF_SIZE);

  LSender :=
    procedure(AConnection: ICrossConnection; ASuccess: Boolean)
    var
      LData: Pointer;
      LCount: Integer;
    begin
      if not ASuccess then
      begin
        LSender := nil;
        LBuffer := nil;

        if Assigned(ACallback) then
          ACallback(AConnection, False);

        AConnection.Close;

        Exit;
      end;

      LData := @LBuffer[0];
      LCount := AStream.Read(LBuffer[0], SND_BUF_SIZE);

      if (LData = nil) or (LCount <= 0) then
      begin
        LSender := nil;
        LBuffer := nil;

        if Assigned(ACallback) then
          ACallback(AConnection, True);

        Exit;
      end;

      TAbstractCrossConnection(AConnection).DirectSend(LData, LCount, LSender);
    end;

  LSender(LConnection, True);
end;

procedure TAbstractCrossConnection.UpdateAddr;
var
  LAddr: TRawSockAddrIn;
begin
  inherited;

  {$region 'remote address information'}
  FillChar(LAddr, SizeOf(TRawSockAddrIn), 0);
  LAddr.AddrLen := SizeOf(LAddr.Addr6);
  if (TSocketAPI.GetPeerName(FSocket, @LAddr.Addr, LAddr.AddrLen) = 0) then
    TSocketAPI.ExtractAddrInfo(@LAddr.Addr, LAddr.AddrLen, FPeerAddr, FPeerPort);
  {$endregion}
end;

function TAbstractCrossConnection._SetConnectStatus(
  const AStatus: TConnectStatus): TConnectStatus;
begin
  Result := TConnectStatus(AtomicExchange(FConnectStatus, Integer(AStatus)));
end;

end.